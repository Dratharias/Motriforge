import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class SchemaMerger {
  constructor(sourceDir, outputFile) {
    this.sourceDir = sourceDir;
    this.outputFile = outputFile;
    this.mergedContent = [];
    this.hasGenerator = false;
    this.hasDatasource = false;
  }

  merge() {
    try {
      console.log("üîÑ Starting schema merge process...");

      const schemaFiles = this.getSchemaFiles();

      if (schemaFiles.length === 0) {
        throw new Error(`No .prisma files found in ${this.sourceDir}`);
      }

      console.log(`üìÅ Found ${schemaFiles.length} schema files:`);
      schemaFiles.forEach((file) => console.log(`   - ${file}`));

      this.addHeader();
      schemaFiles.forEach((file) => this.processFile(file));
      this.writeOutput();

      console.log(`‚úÖ Schema merge completed successfully!`);
      console.log(`üìÑ Output: ${this.outputFile}`);
      console.log(`üìä Total lines: ${this.mergedContent.length}`);
    } catch (error) {
      console.error("‚ùå Schema merge failed:", error.message);
      process.exit(1);
    }
  }

  getSchemaFiles() {
    if (!fs.existsSync(this.sourceDir)) {
      throw new Error(`Source directory does not exist: ${this.sourceDir}`);
    }

    return fs
      .readdirSync(this.sourceDir)
      .filter((file) => file.endsWith(".prisma"))
      .sort();
  }

  addHeader() {
    const header = [
      "// =====================================",
      "// GENERATED PRISMA SCHEMA",
      "// =====================================",
      "//",
      "// This file is auto-generated by merging multiple schema parts.",
      "// Do not edit this file directly - modify files in schema-parts/ instead.",
      "//",
      "// To regenerate: npm run merge",
      "//",
      `// Generated at: ${new Date().toISOString()}`,
      "// =====================================",
      "",
    ];

    this.mergedContent.push(...header);
  }

  processFile(filename) {
    const filePath = path.join(this.sourceDir, filename);
    const content = fs.readFileSync(filePath, "utf8");

    console.log(`üîß Processing: ${filename}`);

    this.mergedContent.push(`// From: ${filename}`);
    this.mergedContent.push("");

    const lines = content.split("\n");
    let skipBlock = false;
    let braceDepth = 0;
    let inBlock = false;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();

      // Skip empty lines at start of files
      if (i === 0 && trimmedLine === "") continue;

      // Check for generator block start
      if (trimmedLine.startsWith("generator ")) {
        if (this.hasGenerator) {
          console.log("   ‚ö†Ô∏è  Skipping duplicate generator block");
          skipBlock = true;
          inBlock = true;
          braceDepth = 0;
          continue;
        }
        this.hasGenerator = true;
        skipBlock = false;
        inBlock = true;
        braceDepth = 0;
      }

      // Check for datasource block start
      if (trimmedLine.startsWith("datasource ")) {
        if (this.hasDatasource) {
          console.log("   ‚ö†Ô∏è  Skipping duplicate datasource block");
          skipBlock = true;
          inBlock = true;
          braceDepth = 0;
          continue;
        }
        this.hasDatasource = true;
        skipBlock = false;
        inBlock = true;
        braceDepth = 0;
      }

      // Track braces when in a block
      if (inBlock) {
        // Count opening braces
        const openBraces = (line.match(/\{/g) || []).length;
        const closeBraces = (line.match(/\}/g) || []).length;

        braceDepth += openBraces;
        braceDepth -= closeBraces;

        // If we're skipping this block, don't add the line
        if (skipBlock) {
          // Check if block is complete
          if (braceDepth === 0 && closeBraces > 0) {
            inBlock = false;
            skipBlock = false;
          }
          continue;
        }

        // Add the line if we're not skipping
        this.mergedContent.push(line);

        // Check if block is complete
        if (braceDepth === 0 && closeBraces > 0) {
          inBlock = false;
        }
      } else {
        // Not in a special block, add the line normally
        this.mergedContent.push(line);
      }
    }

    this.mergedContent.push("");
  }

  writeOutput() {
    const outputDir = path.dirname(this.outputFile);

    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
      console.log(`üìÅ Created output directory: ${outputDir}`);
    }

    const finalContent = this.mergedContent.join("\n");
    fs.writeFileSync(this.outputFile, finalContent, "utf8");
  }
}

function main() {
  const sourceDir = path.join(__dirname, "..", "schema-parts");
  const outputFile = path.join(__dirname, "..", "generated", "schema.prisma");

  console.log(`üìÇ Source directory: ${sourceDir}`);
  console.log(`üìÑ Output file: ${outputFile}`);

  const merger = new SchemaMerger(sourceDir, outputFile);
  merger.merge();
}

if (fileURLToPath(import.meta.url) === process.argv[1]) {
  main();
}

export { SchemaMerger };