// prisma/scripts/merge-schema.js

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

// Recompute __dirname and __filename in ESM context
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Merges multiple Prisma schema files into a single schema.prisma
 * Maintains proper ordering and removes duplicate generator/datasource blocks
 */
class SchemaMerger {
  constructor(sourceDir, outputFile) {
    this.sourceDir = sourceDir;
    this.outputFile = outputFile;
    this.mergedContent = [];
    this.hasGenerator = false;
    this.hasDatasource = false;
  }

  /**
   * Main merge process
   */
  merge() {
    try {
      console.log("ðŸ”„ Starting schema merge process...");

      // Get all .prisma files in the source directory
      const schemaFiles = this.getSchemaFiles();

      if (schemaFiles.length === 0) {
        throw new Error(`No .prisma files found in ${this.sourceDir}`);
      }

      console.log(`ðŸ“ Found ${schemaFiles.length} schema files:`);
      schemaFiles.forEach((file) => console.log(`   - ${file}`));

      // Add header comment
      this.addHeader();

      // Process each file in order
      schemaFiles.forEach((file) => this.processFile(file));

      // Write merged content to output file
      this.writeOutput();

      console.log(`âœ… Schema merge completed successfully!`);
      console.log(`ðŸ“„ Output: ${this.outputFile}`);
      console.log(`ðŸ“Š Total lines: ${this.mergedContent.length}`);
    } catch (error) {
      console.error("âŒ Schema merge failed:", error.message);
      process.exit(1);
    }
  }

  /**
   * Get all .prisma files from source directory, sorted by name
   */
  getSchemaFiles() {
    return fs
      .readdirSync(this.sourceDir)
      .filter((file) => file.endsWith(".prisma"))
      .sort(); // This ensures 00-foundation.prisma comes first
  }

  /**
   * Add header to merged schema
   */
  addHeader() {
    const header = [
      "// =====================================",
      "// GENERATED PRISMA SCHEMA",
      "// =====================================",
      "//",
      "// This file is auto-generated by merging multiple schema parts.",
      "// Do not edit this file directly - modify files in schema-parts/ instead.",
      "//",
      "// To regenerate: npm run prisma:merge",
      "//",
      `// Generated at: ${new Date().toISOString()}`,
      "// =====================================",
      "",
    ];

    this.mergedContent.push(...header);
  }

  /**
   * Process a single schema file
   */
  processFile(filename) {
    const filePath = path.join(this.sourceDir, filename);
    const content = fs.readFileSync(filePath, "utf8");

    console.log(`ðŸ”§ Processing: ${filename}`);

    // Add file separator comment
    this.mergedContent.push(`// From: ${filename}`);
    this.mergedContent.push("");

    // Process content line by line
    const lines = content.split("\n");
    let inGeneratorBlock = false;
    let inDatasourceBlock = false;
    let blockBraceCount = 0;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // Skip empty lines at start of files (but keep them elsewhere)
      if (i === 0 && line === "") continue;

      // Handle generator block
      if (line.startsWith("generator ")) {
        if (this.hasGenerator) {
          console.log("   âš ï¸  Skipping duplicate generator block");
          inGeneratorBlock = true;
          blockBraceCount = 0;
          continue;
        }
        this.hasGenerator = true;
        inGeneratorBlock = true;
        blockBraceCount = 0;
      }

      // Handle datasource block
      if (line.startsWith("datasource ")) {
        if (this.hasDatasource) {
          console.log("   âš ï¸  Skipping duplicate datasource block");
          inDatasourceBlock = true;
          blockBraceCount = 0;
          continue;
        }
        this.hasDatasource = true;
        inDatasourceBlock = true;
        blockBraceCount = 0;
      }

      // Track braces to know when blocks end
      if (inGeneratorBlock || inDatasourceBlock) {
        if (line.includes("{")) blockBraceCount++;
        if (line.includes("}")) blockBraceCount--;

        if (blockBraceCount === 0 && (line.includes("}") || line === "")) {
          inGeneratorBlock = false;
          inDatasourceBlock = false;
          if (!this.hasGenerator && !this.hasDatasource) {
            this.mergedContent.push(lines[i]); // Keep the closing brace
          }
          continue;
        }

        // Skip content of duplicate blocks
        if (
          (inGeneratorBlock && this.hasGenerator && blockBraceCount > 0) ||
          (inDatasourceBlock && this.hasDatasource && blockBraceCount > 0)
        ) {
          continue;
        }
      }

      // Add the line (restore original with whitespace)
      this.mergedContent.push(lines[i]);
    }

    // Add separator
    this.mergedContent.push("");
  }

  /**
   * Write merged content to output file
   */
  writeOutput() {
    const outputDir = path.dirname(this.outputFile);

    // Ensure output directory exists
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Write content
    const finalContent = this.mergedContent.join("\n");
    fs.writeFileSync(this.outputFile, finalContent, "utf8");
  }
}

/**
 * CLI interface
 */
function main() {
  const sourceDir = path.join(__dirname, "..", "schema-parts");
  const outputFile = path.join(__dirname, "..", "schema.prisma");

  const merger = new SchemaMerger(sourceDir, outputFile);
  merger.merge();
}

// If this script is invoked directly, run main()
if (fileURLToPath(import.meta.url) === process.argv[1]) {
  main();
}

export { SchemaMerger };
