classDiagram
    %% ===== MEDIA ENTITY =====
    class Media {
        +id: Types.ObjectId
        +url: string
        +type: MediaType
        +title?: string
        +description?: string
        +metadata: IMediaMetadata
        +associatedTo: readonly Types.ObjectId[]
        +associatedResourceTypes: readonly ResourceType[]
        +tags: readonly string[]
        +isPublic: boolean
        +organization: Types.ObjectId
        +uploadedBy: Types.ObjectId
        +createdAt: Date
        +updatedAt: Date
        +createdBy: Types.ObjectId
        +isActive: boolean
        +isDraft: boolean
        +constructor(data)
        +isVideo(): boolean
        +isImage(): boolean
        +isAudio(): boolean
        +isDocument(): boolean
        +isAccessibleBy(user: IUser): boolean
        +getProcessedUrl(quality?: MediaQuality): string
        +getFileName(): string
        +getFileExtension(): string
        +getFileSizeFormatted(): string
        +getDurationFormatted(): string | null
        +hasTag(tag: string): boolean
        +addTag(tag: string): Media
        +removeTag(tag: string): Media
        +isAssociatedWith(resourceId: Types.ObjectId): boolean
        +isAssociatedWithResourceType(resourceType: ResourceType): boolean
        +addAssociation(resourceId: Types.ObjectId, resourceType: ResourceType): Media
        +removeAssociation(resourceId: Types.ObjectId): Media
        +update(updates): Media
        +setPublicAccess(isPublic: boolean): Media
        +hasRequiredQuality(quality: MediaQuality): boolean
        +isOptimizedForWeb(): boolean
        +exceedsFileSizeLimit(limitMB: number): boolean
        +canBeDeleted(): boolean
        +getAssociationCount(): number
        +canBeSharedWith(user: IUser): boolean
        +share(targetUser: IUser, permissions: readonly Action[]): Promise~void~
        +archive(): void
        +restore(): void
    }

    %% ===== MEDIA METADATA =====
    class IMediaMetadata {
        <<interface>>
        +fileSize: number
        +duration?: number
        +resolution?: IResolution
        +format: string
        +compressionInfo?: ICompressionInfo
        +fps?: number
        +sampleRate?: number
        +channels?: number
        +colorProfile?: string
        +orientation?: number
        +capturedAt?: Date
        +gpsLocation?: (latitude: number, longitude: number)
        +cameraInfo?: ICameraInfo
    }

    class IResolution {
        <<interface>>
        +width: number
        +height: number
    }

    class ICompressionInfo {
        <<interface>>
        +originalSize: number
        +compressionRatio: number
        +codec: string
        +bitrate?: number
        +quality?: number
    }

    class ICameraInfo {
        <<interface>>
        +make?: string
        +model?: string
        +lens?: string
        +settings?: Record~string, unknown~
    }

    %% ===== MEDIA SERVICE =====
    class MediaService {
        -mediaRepository: IMediaRepository
        -storageService: IMediaStorageService
        -processingService: IMediaProcessingService
        -accessService: IMediaAccessService
        +constructor(mediaRepository, storageService, processingService, accessService)
        +uploadMedia(data: IMediaUploadData): Promise~Media~
        +getMediaById(id: Types.ObjectId): Promise~Media | null~
        +getMediaByTitle(title: string): Promise~readonly Media[]~
        +getMediaByType(type: MediaType): Promise~readonly Media[]~
        +getOrganizationMedia(organizationId: Types.ObjectId): Promise~readonly Media[]~
        +getUserMedia(userId: Types.ObjectId): Promise~readonly Media[]~
        +getMediaByTags(tags: readonly string[]): Promise~readonly Media[]~
        +getAssociatedMedia(resourceId: Types.ObjectId): Promise~readonly Media[]~
        +getPublicMedia(): Promise~readonly Media[]~
        +updateMedia(id: Types.ObjectId, updates, userId: Types.ObjectId): Promise~Media | null~
        +associateMedia(mediaId: Types.ObjectId, resourceId: Types.ObjectId, resourceType: ResourceType, userId: Types.ObjectId): Promise~Media | null~
        +removeAssociation(mediaId: Types.ObjectId, resourceId: Types.ObjectId, userId: Types.ObjectId): Promise~Media | null~
        +addMediaTag(mediaId: Types.ObjectId, tag: string, userId: Types.ObjectId): Promise~Media | null~
        +removeMediaTag(mediaId: Types.ObjectId, tag: string, userId: Types.ObjectId): Promise~Media | null~
        +processMedia(mediaId: Types.ObjectId, options: IMediaProcessingOptions, userId: Types.ObjectId): Promise~Media~
        +generateThumbnail(mediaId: Types.ObjectId, userId: Types.ObjectId): Promise~string~
        +optimizeForWeb(mediaId: Types.ObjectId, userId: Types.ObjectId): Promise~Media~
        +searchMedia(criteria: IMediaSearchCriteria): Promise~readonly Media[]~
        +getMediaStatistics(organizationId?: Types.ObjectId): Promise~IMediaStatistics~
        +getTotalStorageUsed(organizationId: Types.ObjectId): Promise~number~
        +findDuplicateMedia(organizationId: Types.ObjectId): Promise~readonly Media[][]~
        +findLargeFiles(organizationId: Types.ObjectId, minSizeMB: number): Promise~readonly Media[]~
        +findOrphanedMedia(organizationId: Types.ObjectId): Promise~readonly Media[]~
        +setMediaPublicAccess(mediaId: Types.ObjectId, isPublic: boolean, userId: Types.ObjectId): Promise~Media | null~
        +downloadMedia(mediaId: Types.ObjectId, userId: Types.ObjectId): Promise~Buffer~
        +archiveMedia(id: Types.ObjectId, userId: Types.ObjectId): Promise~boolean~
        +restoreMedia(id: Types.ObjectId, userId: Types.ObjectId): Promise~boolean~
        +deleteMedia(id: Types.ObjectId, userId: Types.ObjectId): Promise~boolean~
        +bulkUploadMedia(files: readonly IMediaUploadData[]): Promise~readonly Media[]~
        +getStorageQuota(organizationId: Types.ObjectId): Promise~(used, limit, remaining)~
        +validateMediaAccess(mediaId: Types.ObjectId, userId: Types.ObjectId): Promise~boolean~
        -validateMediaUpload(data: IMediaUploadData): Promise~void~
        -validateMediaTitle(title: string): void
        -validateMediaDescription(description: string): void
        -validateMediaTags(tags: readonly string[]): void
    }

    %% ===== MEDIA PROCESSING SERVICE =====
    class MediaProcessingService {
        -mediaRepository: IMediaRepository
        -storageService: IMediaStorageService
        +constructor(mediaRepository, storageService)
        +processMedia(mediaId: Types.ObjectId, options: IMediaProcessingOptions): Promise~Media~
        +generateThumbnail(mediaId: Types.ObjectId): Promise~string~
        +optimizeForWeb(mediaId: Types.ObjectId): Promise~Media~
        +extractMetadata(file: Buffer, mimeType: string): Promise~IMediaMetadata~
        +validateMedia(file: Buffer, mimeType: string): Promise~IMediaValidationResult~
        +convertFormat(mediaId: Types.ObjectId, targetFormat: string): Promise~Media~
        +compressMedia(mediaId: Types.ObjectId, compressionLevel: number): Promise~Media~
        +addWatermark(mediaId: Types.ObjectId, watermarkOptions): Promise~Media~
        +createVariants(mediaId: Types.ObjectId, qualities: readonly MediaQuality[]): Promise~readonly Media[]~
        -processImage(buffer: Buffer, options: IMediaProcessingOptions, originalMetadata: IMediaMetadata): Promise~(buffer, metadata)~
        -processVideo(buffer: Buffer, options: IMediaProcessingOptions, originalMetadata: IMediaMetadata): Promise~(buffer, metadata)~
        -processAudio(buffer: Buffer, options: IMediaProcessingOptions, originalMetadata: IMediaMetadata): Promise~(buffer, metadata)~
        -createThumbnail(buffer: Buffer, mediaType: MediaType): Promise~Buffer~
        -extractImageMetadata(file: Buffer, baseMetadata: IMediaMetadata): Promise~IMediaMetadata~
        -extractVideoMetadata(file: Buffer, baseMetadata: IMediaMetadata): Promise~IMediaMetadata~
        -extractAudioMetadata(file: Buffer, baseMetadata: IMediaMetadata): Promise~IMediaMetadata~
        -validateImage(metadata, errors, warnings, suggestions): void
        -validateVideo(metadata, errors, warnings, suggestions): void
        -validateAudio(metadata, errors, warnings, suggestions): void
        -getQualitySettings(quality: MediaQuality): (maxWidth?, maxHeight?, compressionLevel?)
        -calculateNewResolution(original, maxWidth, maxHeight, maintainAspectRatio): (width, height)
        -getMediaTypeFromMimeType(mimeType: string): MediaType
        -getFormatFromMimeType(mimeType: string): string
        -getMimeType(mediaType: MediaType, format: string): string
        -getFileExtension(url: string): string
        -getFileName(url: string): string
    }

    %% ===== REPOSITORY INTERFACES =====
    class IMediaRepository {
        <<interface>>
        +findById(id: Types.ObjectId): Promise~Media | null~
        +findByTitle(title: string): Promise~readonly Media[]~
        +findByType(type: MediaType): Promise~readonly Media[]~
        +findByOrganization(organizationId: Types.ObjectId): Promise~readonly Media[]~
        +findByUploader(uploaderId: Types.ObjectId): Promise~readonly Media[]~
        +findByTags(tags: readonly string[]): Promise~readonly Media[]~
        +findAssociatedWith(resourceId: Types.ObjectId): Promise~readonly Media[]~
        +findPublicMedia(): Promise~readonly Media[]~
        +findOrphanedMedia(organizationId: Types.ObjectId): Promise~readonly Media[]~
        +search(criteria: IMediaSearchCriteria): Promise~readonly Media[]~
        +create(media: Omit~Media, NewEntity~): Promise~Media~
        +update(id: Types.ObjectId, updates: Partial~Media~): Promise~Media | null~
        +archive(id: Types.ObjectId): Promise~boolean~
        +restore(id: Types.ObjectId): Promise~boolean~
        +delete(id: Types.ObjectId): Promise~boolean~
        +getStatistics(organizationId?: Types.ObjectId): Promise~IMediaStatistics~
        +getTotalStorageUsed(organizationId: Types.ObjectId): Promise~number~
        +findDuplicates(organizationId: Types.ObjectId): Promise~readonly Media[][]~
        +findLargeFiles(organizationId: Types.ObjectId, minSizeMB: number): Promise~readonly Media[]~
    }

    %% ===== SERVICE INTERFACES =====
    class IMediaProcessingService {
        <<interface>>
        +processMedia(mediaId: Types.ObjectId, options: IMediaProcessingOptions): Promise~Media~
        +generateThumbnail(mediaId: Types.ObjectId): Promise~string~
        +optimizeForWeb(mediaId: Types.ObjectId): Promise~Media~
        +extractMetadata(file: Buffer, mimeType: string): Promise~IMediaMetadata~
        +validateMedia(file: Buffer, mimeType: string): Promise~IMediaValidationResult~
        +convertFormat(mediaId: Types.ObjectId, targetFormat: string): Promise~Media~
        +compressMedia(mediaId: Types.ObjectId, compressionLevel: number): Promise~Media~
        +addWatermark(mediaId: Types.ObjectId, watermarkOptions): Promise~Media~
        +createVariants(mediaId: Types.ObjectId, qualities: readonly MediaQuality[]): Promise~readonly Media[]~
    }

    class IMediaStorageService {
        <<interface>>
        +upload(data: IMediaUploadData): Promise~(url: string, metadata: IMediaMetadata)~
        +download(url: string): Promise~Buffer~
        +delete(url: string): Promise~boolean~
        +copy(sourceUrl: string, destinationUrl: string): Promise~string~
        +move(sourceUrl: string, destinationUrl: string): Promise~string~
        +exists(url: string): Promise~boolean~
        +getFileInfo(url: string): Promise~(size: number, lastModified: Date, contentType: string)~
        +generateSignedUrl(url: string, expirationMinutes: number): Promise~string~
        +bulkUpload(files: readonly IMediaUploadData[]): Promise~readonly (url: string, metadata: IMediaMetadata)[]~
        +bulkDelete(urls: readonly string[]): Promise~readonly boolean[]~
        +getStorageQuota(organizationId: Types.ObjectId): Promise~(used: number, limit: number, remaining: number)~
    }

    class IMediaAccessService {
        <<interface>>
        +checkAccess(mediaId: Types.ObjectId, userId: Types.ObjectId, accessType: string): Promise~boolean~
        +grantAccess(mediaId: Types.ObjectId, userId: Types.ObjectId, permissions: readonly string[]): Promise~boolean~
        +revokeAccess(mediaId: Types.ObjectId, userId: Types.ObjectId): Promise~boolean~
        +getAccessPermissions(mediaId: Types.ObjectId, userId: Types.ObjectId): Promise~readonly string[]~
        +logAccess(log: Omit~IMediaAccessLog, 'id' | 'timestamp'~): Promise~IMediaAccessLog~
        +getAccessHistory(mediaId: Types.ObjectId): Promise~readonly IMediaAccessLog[]~
        +getUserAccessHistory(userId: Types.ObjectId): Promise~readonly IMediaAccessLog[]~
        +findMostAccessedMedia(organizationId: Types.ObjectId, limit: number): Promise~readonly (media: Media, accessCount: number)[]~
    }

    %% ===== DATA TRANSFER OBJECTS =====
    class IMediaUploadData {
        <<interface>>
        +file: Buffer | string
        +filename: string
        +mimeType: string
        +type: MediaType
        +title?: string
        +description?: string
        +tags?: readonly string[]
        +isPublic?: boolean
        +organizationId: Types.ObjectId
        +uploadedBy: Types.ObjectId
        +associatedTo?: readonly Types.ObjectId[]
        +associatedResourceTypes?: readonly ResourceType[]
    }

    class IMediaSearchCriteria {
        <<interface>>
        +title?: string
        +description?: string
        +type?: MediaType
        +tags?: readonly string[]
        +organizationId?: Types.ObjectId
        +uploadedBy?: Types.ObjectId
        +isPublic?: boolean
        +status?: Status
        +associatedResourceType?: ResourceType
        +minFileSize?: number
        +maxFileSize?: number
        +minDuration?: number
        +maxDuration?: number
        +format?: string
        +hasResolution?: boolean
        +minWidth?: number
        +maxWidth?: number
        +minHeight?: number
        +maxHeight?: number
        +uploadedAfter?: Date
        +uploadedBefore?: Date
        +hasGpsLocation?: boolean
    }

    class IMediaProcessingOptions {
        <<interface>>
        +targetQuality: MediaQuality
        +maxWidth?: number
        +maxHeight?: number
        +compressionLevel?: number
        +format?: string
        +maintainAspectRatio?: boolean
        +watermark?: (text: string, position: string, opacity: number)
    }

    class IMediaValidationResult {
        <<interface>>
        +isValid: boolean
        +errors: readonly string[]
        +warnings: readonly string[]
        +suggestions: readonly string[]
        +metadata?: IMediaMetadata
    }

    class IMediaStatistics {
        <<interface>>
        +totalMedia: number
        +mediaByType: Record~MediaType, number~
        +mediaByStatus: Record~Status, number~
        +totalFileSize: number
        +averageFileSize: number
        +publicMediaCount: number
        +privateMediaCount: number
        +orphanedMediaCount: number
        +mediaByFormat: Record~string, number~
        +storageUsageByOrganization: Record~string, number~
        +uploadTrends: (daily: Record~string, number~, monthly: Record~string, number~)
    }

    class IMediaAccessLog {
        <<interface>>
        +id: Types.ObjectId
        +mediaId: Types.ObjectId
        +userId: Types.ObjectId
        +accessType: 'VIEW' | 'DOWNLOAD' | 'SHARE' | 'EDIT'
        +ipAddress?: string
        +userAgent?: string
        +timestamp: Date
        +success: boolean
        +errorReason?: string
    }

    %% ===== RELATIONSHIPS =====
    Media ..|> IEntity
    Media ..|> IArchivable
    Media ..|> IShareable
    Media --> IMediaMetadata : has
    Media --> ResourceType : associated with
    
    IMediaMetadata --> IResolution : contains
    IMediaMetadata --> ICompressionInfo : contains
    IMediaMetadata --> ICameraInfo : contains

    MediaService --> IMediaRepository : uses
    MediaService --> IMediaStorageService : uses
    MediaService --> IMediaProcessingService : uses
    MediaService --> IMediaAccessService : uses
    MediaService --> Media : manages
    MediaService --> IMediaUploadData : accepts
    MediaService --> IMediaSearchCriteria : uses
    MediaService --> IMediaProcessingOptions : uses
    MediaService --> IMediaStatistics : returns

    MediaProcessingService ..|> IMediaProcessingService
    MediaProcessingService --> IMediaRepository : uses
    MediaProcessingService --> IMediaStorageService : uses
    MediaProcessingService --> IMediaValidationResult : returns
    MediaProcessingService --> IMediaMetadata : processes

    IMediaRepository --> Media : manages
    IMediaAccessService --> IMediaAccessLog : manages

    %% ===== ENUM USAGE NOTES =====
    note for Media "Uses: MediaType, MediaQuality, ResourceType, Status enums"
    note for IMediaSearchCriteria "Uses: MediaType, ResourceType, Status enums"
    note for IMediaProcessingOptions "Uses: MediaQuality enum"
    note for IMediaStatistics "Uses: MediaType, Status enums"