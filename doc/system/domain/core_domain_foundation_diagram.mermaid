classDiagram
    %% ===== CORE INTERFACES =====
    class IEntity {
        <<interface>>
        +id: Types.ObjectId
        +createdAt: Date
        +updatedAt: Date
        +createdBy: Types.ObjectId
        +isActive: boolean
        +isDraft: boolean
    }

    class IUser {
        <<interface>>
        +id: Types.ObjectId
        +email: string
        +role: Role
        +status: string
        +organization: Types.ObjectId
        +createdAt: Date
        +lastActiveAt?: Date
    }

    class IError {
        <<interface>>
        +code: string
        +message: string
        +severity: Severity
        +timestamp: Date
        +context?: string
        +origin?: string
        +stack?: string
        +traceId?: string
        +userId?: string
    }

    class IEvent {
        <<interface>>
        +id: string
        +type: EventType
        +timestamp: Date
        +source: string
        +payload: unknown
        +originUserId?: string
        +sessionId?: string
        +traceId?: string
        +context?: string
        +handledBy?: readonly string[]
        +metadata?: Record~string, unknown~
    }

    class IEventHandler {
        <<interface>>
        +supports(eventType: EventType): boolean
        +handle(event: IEvent): Promise~void~
        +priority?: number
    }

    class IResourcePermission {
        <<interface>>
        +resource: ResourceType
        +actions: readonly Action[]
        +conditions?: Record~string, unknown~
    }

    class IErrorWrapper {
        <<interface>>
        +type: ErrorType
        +error: IError
        +metadata?: Record~string, unknown~
    }

    %% ===== VALIDATION SYSTEM =====
    class ValidationError {
        +field: string
        +message: string
        +code: string
        +severity: ValidationSeverity
        +context?: unknown
    }

    class ValidationWarning {
        +field: string
        +message: string
        +suggestion?: string
    }

    class ValidationResult {
        +isValid: boolean
        +errors: readonly ValidationError[]
        +warnings: readonly ValidationWarning[]
        +isDraftValid: boolean
        +requiredForPublication: readonly string[]
        +canSaveDraft(): boolean
        +canPublish(): boolean
    }

    class IValidatable {
        <<interface>>
        +validate(): ValidationResult
        +validateDraft(): ValidationResult
        +isValid(): boolean
        +isDraftValid(): boolean
        +getValidationErrors(): readonly ValidationError[]
        +getDraftValidationErrors(): readonly ValidationError[]
    }

    %% ===== BEHAVIOR INTERFACES =====
    class ICloneable~T~ {
        <<interface>>
        +clone(): T
        +cloneWithModifications(modifications: Partial~T~): T
    }

    class IDraftPreview {
        <<interface>>
        +completionPercentage: number
        +missingRequiredFields: string[]
        +optionalFieldsCompleted: string[]
        +estimatedTimeToComplete: number
        +lastModified: Date
    }

    class IDraftable {
        <<interface>>
        +isDraft: boolean
        +validateForPublication(): ValidationResult
        +canBePublished(): boolean
        +publish(): void
        +saveDraft(): void
        +getDraftPreview(): IDraftPreview
        +getPublicationRequirements(): readonly string[]
    }

    class IShareable {
        <<interface>>
        +canBeSharedWith(user: IUser): boolean
        +share(targetUser: IUser, permissions: readonly Action[]): Promise~void~
    }

    class IArchivable {
        <<interface>>
        +archive(): void
        +restore(): void
        +canBeDeleted(): boolean
        +getAssociationCount(): number
    }

    class IVersionable~T~ {
        <<interface>>
        +version: number
        +previousVersions: readonly Types.ObjectId[]
        +createVersion(): T
        +getPreviousVersion(version: number): Promise~T | null~
    }

    %% ===== SHARED RESOURCE SYSTEM =====
    class SharedResource {
        +id: Types.ObjectId
        +resourceId: Types.ObjectId
        +resourceType: ResourceType
        +owner: Types.ObjectId
        +sharedWith: readonly Types.ObjectId[]
        +allowedActions: readonly Action[]
        +startDate: Date
        +endDate?: Date
        +conditions: readonly IShareCondition[]
        +archived: boolean
        +notes: string
        +createdAt: Date
        +isValid(): boolean
        +hasExpired(): boolean
        +canUserAccess(user: IUser, action: Action): boolean
        +addSharedUser(user: IUser): void
        +removeSharedUser(userId: Types.ObjectId): void
        +archive(): void
    }

    class IShareCondition {
        <<interface>>
        +type: string
        +value: any
        +operator: string
    }

    %% ===== IAM SYSTEM =====
    class PermissionSet {
        +role: Role
        +permissions: readonly IResourcePermission[]
        +description: string
        +isActive: boolean
        +allows(resource: ResourceType, action: Action): boolean
        +addPermission(permission: IResourcePermission): void
        +removePermission(resource: ResourceType): void
        +getPermissions(): readonly IResourcePermission[]
    }

    class IAMService {
        -permissionSets: PermissionSet[]
        -auditLogger: IAMLogger
        +canAccess(user: IUser, resource: ResourceType, action: Action): boolean
        +canShare(user: IUser, target: IUser, resource: ResourceType): boolean
        +hasPermission(user: IUser, permission: IResourcePermission): boolean
        +getRolePermissions(role: Role): PermissionSet
        +validateAccess(user: IUser, resource: ResourceType, action: Action): Promise~boolean~
        +auditAccess(user: IUser, resource: ResourceType, action: Action, granted: boolean): void
    }

    %% ===== EVENT SYSTEM =====
    class EventBus {
        -handlers: readonly IEventHandler[]
        -eventHistory: readonly IEvent[]
        -maxHistorySize: number
        +register(handler: IEventHandler): void
        +unregister(handler: IEventHandler): void
        +emit(event: IEvent): Promise~void~
        +getHandlers(eventType: EventType): readonly IEventHandler[]
        +getEventHistory(limit?: number): readonly IEvent[]
        +clearHistory(): void
    }

    class BaseEvent {
        +id: string
        +type: EventType
        +timestamp: Date
        +source: string
        +payload: any
        +originUserId?: string
        +sessionId?: string
        +traceId?: string
        +context?: string
        +handledBy: string[]
        +metadata: Record~string, any~
        +addHandler(handlerName: string): void
        +isHandledBy(handlerName: string): boolean
    }

    class UserEvent {
        +userId: string
        +action: string
        +previousState?: any
        +newState?: any
        +getUserDetails(): any
    }

    class SecurityEvent {
        +userId: string
        +resource: ResourceType
        +action: Action
        +success: boolean
        +reason?: string
        +ipAddress?: string
        +userAgent?: string
        +getThreatLevel(): Severity
    }

    class SystemEvent {
        +component: string
        +operation: string
        +success: boolean
        +duration?: number
        +error?: IError
        +isHealthCheck(): boolean
    }

    class SharingEvent {
        +resourceId: string
        +resourceType: ResourceType
        +sharedBy: string
        +sharedWith: readonly string[]
        +permissions: readonly Action[]
        +expiresAt?: Date
        +getResourceDetails(): any
    }

    %% ===== EVENT HANDLERS =====
    class AuditEventHandler {
        -auditLogger: AuditLogger
        +priority: number
        +supports(eventType: EventType): boolean
        +handle(event: IEvent): Promise~void~
    }

    class SecurityEventHandler {
        -securityService: any
        +priority: number
        +supports(eventType: EventType): boolean
        +handle(event: IEvent): Promise~void~
        +checkThreatLevel(event: SecurityEvent): Severity
    }

    class NotificationEventHandler {
        -notificationService: any
        +priority: number
        +supports(eventType: EventType): boolean
        +handle(event: IEvent): Promise~void~
        +shouldNotify(event: IEvent): boolean
    }

    class MetricsEventHandler {
        -metricsService: any
        +priority: number
        +supports(eventType: EventType): boolean
        +handle(event: IEvent): Promise~void~
        +recordMetric(event: IEvent): void
    }

    %% ===== TYPE UTILITIES =====
    class NewEntity {
        <<type>>
        'id' | 'createdAt' | 'updatedAt'
    }

    %% ===== RELATIONSHIPS =====
    ValidationResult --> ValidationError : contains
    ValidationResult --> ValidationWarning : contains
    IValidatable --> ValidationResult : returns
    IDraftable --> ValidationResult : returns
    IDraftable --> IDraftPreview : returns
    IVersionable --> IEntity : version of

    SharedResource ..|> IEntity
    SharedResource ..|> IArchivable
    SharedResource --> IUser : owner/shared with
    SharedResource --> IShareCondition : uses
    SharedResource --> ResourceType : typed by
    SharedResource --> Action : allows

    PermissionSet --> Role : for role
    PermissionSet --> IResourcePermission : contains
    IAMService --> PermissionSet : manages
    IAMService --> IUser : authorizes

    EventBus --> IEventHandler : manages
    EventBus --> IEvent : processes
    BaseEvent ..|> IEvent
    BaseEvent <|-- UserEvent
    BaseEvent <|-- SecurityEvent
    BaseEvent <|-- SystemEvent
    BaseEvent <|-- SharingEvent

    IEventHandler <|.. AuditEventHandler
    IEventHandler <|.. SecurityEventHandler
    IEventHandler <|.. NotificationEventHandler
    IEventHandler <|.. MetricsEventHandler

    SecurityEventHandler --> SecurityEvent : handles
    
    %% ===== ENUM USAGE NOTES =====
    note for IUser "Uses: Role, Status enums"
    note for IError "Uses: Severity enum"
    note for IEvent "Uses: EventType enum"
    note for IResourcePermission "Uses: ResourceType, Action enums"
    note for IErrorWrapper "Uses: ErrorType enum"
    note for ValidationError "Uses: ValidationSeverity enum"
    note for SecurityEvent "Uses: ResourceType, Action, Severity enums"
    note for BaseEvent "Uses: EventType enum"