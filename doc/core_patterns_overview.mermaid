classDiagram
    %% ===== PRESENTATION LAYER =====
    class APIGateway {
        <<Gateway>>
        -middlewareChain: MiddlewareChain
        -routeResolver: RouteResolver
        -securityContext: SecurityContext
        +route(request: HttpRequest): Promise~HttpResponse~
        +applyMiddleware(context: RequestContext): Promise~void~
        +authenticate(credentials: Credentials): Promise~SecurityContext~
        +authorize(action: string, resource: string): Promise~boolean~
    }
    
    class MiddlewareChain {
        <<Chain of Responsibility>>
        -middlewares: IMiddleware[]
        -registry: MiddlewareRegistry
        +add(middleware: IMiddleware): MiddlewareChain
        +execute(context: RequestContext): Promise~RequestContext~
        +remove(middlewareName: string): boolean
    }
    
    class IMiddleware {
        <<Strategy Pattern>>
        +execute(context: RequestContext, next: NextFunction): Promise~void~
        +getName(): string
        +isEnabled(): boolean
    }
    
    %% ===== APPLICATION LAYER =====
    class ApplicationFacade {
        <<Facade Pattern>>
        -commandBus: ICommandBus
        -queryBus: IQueryBus
        -eventBus: IEventBus
        -contextRegistry: ContextRegistry
        +executeCommand~T~(command: ICommand~T~): Promise~T~
        +executeQuery~T~(query: IQuery~T~): Promise~T~
        +publishEvent(event: DomainEvent): Promise~void~
        +getContext(contextName: string): BoundedContext
    }
    
    class CommandBus {
        <<CQRS Pattern>>
        -handlerRegistry: HandlerRegistry
        -pipeline: CommandPipeline
        -eventStore: IEventStore
        +dispatch~T~(command: ICommand~T~): Promise~T~
        +registerHandler(commandType: string, handler: ICommandHandler): void
        +validate(command: ICommand): ValidationResult
    }
    
    class QueryBus {
        <<CQRS Pattern>>
        -handlerRegistry: HandlerRegistry
        -cacheStrategy: QueryCacheStrategy
        -readModelStore: IReadModelStore
        +dispatch~T~(query: IQuery~T~): Promise~T~
        +registerHandler(queryType: string, handler: IQueryHandler): void
        +getCachedResult~T~(query: IQuery~T~): Promise~T | null~
    }
    
    class EventBus {
        <<Event Sourcing Pattern>>
        -eventStore: IEventStore
        -subscribers: EventSubscriber[]
        -sagaOrchestrator: ISagaOrchestrator
        -projectionEngine: IProjectionEngine
        +publish(event: DomainEvent): Promise~void~
        +subscribe(eventType: string, handler: IEventHandler): void
        +replay(aggregateId: string): Promise~DomainEvent[]~
        +project(event: DomainEvent): Promise~void~
    }
    
    %% ===== DOMAIN LAYER =====
    class BoundedContext {
        <<Domain-Driven Design>>
        -contextName: string
        -aggregateRoots: Map~string, AggregateRoot~
        -domainServices: DomainService[]
        -ports: Port[]
        +getAggregate~T~(id: string): Promise~T~
        +executeCommand(command: ICommand): Promise~void~
        +handleEvent(event: DomainEvent): Promise~void~
    }
    
    class AggregateRoot {
        <<Aggregate Pattern>>
        -id: string
        -version: number
        -domainEvents: DomainEvent[]
        -lastModified: Date
        +apply(event: DomainEvent): void
        +getUncommittedEvents(): DomainEvent[]
        +markEventsAsCommitted(): void
        +validate(): ValidationResult
    }
    
    class DomainEvent {
        <<Event Sourcing>>
        -eventId: string
        -aggregateId: string
        -eventType: string
        -eventData: any
        -timestamp: Date
        -version: number
        +getMetadata(): EventMetadata
        +serialize(): string
        +deserialize(data: string): DomainEvent
    }
    
    class Port {
        <<Hexagonal Architecture>>
        +getContract(): InterfaceContract
        +isImplemented(): boolean
        +getAdapter(): Adapter
    }
    
    %% ===== INFRASTRUCTURE LAYER =====
    class Adapter {
        <<Hexagonal Architecture>>
        -port: Port
        -externalService: ExternalService
        +connect(): Promise~void~
        +disconnect(): Promise~void~
        +healthCheck(): Promise~HealthStatus~
        +execute(operation: Operation): Promise~Result~
    }
    
    class EventStore {
        <<Event Sourcing>>
        -persistence: IEventPersistence
        -serializer: IEventSerializer
        -snapshotStore: ISnapshotStore
        +append(streamId: string, events: DomainEvent[]): Promise~void~
        +getEvents(streamId: string, fromVersion?: number): Promise~DomainEvent[]~
        +saveSnapshot(aggregateId: string, snapshot: Snapshot): Promise~void~
        +getSnapshot(aggregateId: string): Promise~Snapshot | null~
    }
    
    class ReadModelStore {
        <<CQRS Pattern>>
        -projections: Map~string, ReadModel~
        -cache: ICacheService
        -database: IDatabase
        +project(event: DomainEvent): Promise~void~
        +query~T~(criteria: QueryCriteria): Promise~T[]~
        +invalidate(modelType: string, id: string): Promise~void~
    }
    
    class CacheManager {
        <<Cache-Aside Pattern>>
        -adapters: Map~string, ICacheAdapter~
        -policies: Map~string, CachePolicy~
        -healthMonitor: CacheHealthMonitor
        +get~T~(key: string): Promise~T | null~
        +set~T~(key: string, value: T, options: CacheOptions): Promise~void~
        +invalidate(pattern: string): Promise~void~
        +warming(keys: string[]): Promise~void~
    }
    
    %% ===== CROSS-CUTTING CONCERNS =====
    class SecurityContext {
        <<Security Pattern>>
        -user: User
        -permissions: Permission[]
        -roles: Role[]
        -session: Session
        +authenticate(credentials: Credentials): Promise~AuthResult~
        +authorize(resource: string, action: string): Promise~boolean~
        +hasPermission(permission: string): boolean
        +isInRole(role: string): boolean
    }
    
    class ServiceRegistry {
        <<Service Locator Pattern>>
        -services: Map~string, ServiceDescriptor~
        -factories: Map~string, ServiceFactory~
        -healthCheckers: Map~string, HealthChecker~
        +register~T~(key: string, factory: ServiceFactory~T~): void
        +resolve~T~(key: string): T
        +discover(serviceName: string): ServiceInstance[]
        +healthCheck(): Promise~HealthStatus~
    }
    
    class MetricsCollector {
        <<Observer Pattern>>
        -collectors: Map~string, MetricCollector~
        -aggregators: MetricsAggregator[]
        -publishers: MetricsPublisher[]
        +record(metric: Metric): Promise~void~
        +increment(counter: string, tags?: Tags): Promise~void~
        +gauge(metric: string, value: number): Promise~void~
        +histogram(metric: string, value: number): Promise~void~
    }
    
    class ConfigurationManager {
        <<Strategy Pattern>>
        -providers: ConfigProvider[]
        -cache: IConfigCache
        -watchers: Map~string, ConfigWatcher~
        +get~T~(key: string): T
        +set(key: string, value: any): Promise~void~
        +watch(key: string, callback: ConfigCallback): void
        +reload(): Promise~void~
    }
    
    %% ===== ADVANCED PATTERNS =====
    class SagaOrchestrator {
        <<Saga Pattern>>
        -sagas: Map~string, Saga~
        -stateStore: ISagaStateStore
        -compensationManager: CompensationManager
        +start(sagaType: string, data: SagaData): Promise~string~
        +handle(event: DomainEvent): Promise~void~
        +compensate(sagaId: string): Promise~void~
        +complete(sagaId: string): Promise~void~
    }
    
    class CircuitBreaker {
        <<Circuit Breaker Pattern>>
        -state: CircuitBreakerState
        -failureThreshold: number
        -timeout: number
        -healthMonitor: IHealthMonitor
        +execute~T~(operation: () => Promise~T~): Promise~T~
        +getState(): CircuitBreakerState
        +reset(): void
        +forceOpen(): void
    }
    
    class PluginManager {
        <<Plugin Pattern>>
        -plugins: Map~string, Plugin~
        -sandbox: PluginSandbox
        -versionManager: IVersionManager
        +loadPlugin(pluginId: string): Promise~void~
        +unloadPlugin(pluginId: string): Promise~void~
        +executePlugin~T~(pluginId: string, method: string, args: any[]): Promise~T~
        +validatePlugin(plugin: Plugin): ValidationResult
    }
    
    class WorkflowEngine {
        <<Workflow Pattern>>
        -workflows: Map~string, WorkflowDefinition~
        -stateManager: WorkflowStateManager
        -executor: WorkflowExecutor
        +start(workflowType: string, input: WorkflowInput): Promise~string~
        +execute(workflowId: string): Promise~WorkflowResult~
        +pause(workflowId: string): Promise~void~
        +resume(workflowId: string): Promise~void~
    }
    
    %% ===== CONTEXT-SPECIFIC COMPONENTS =====
    class UserManagementContext {
        <<Bounded Context>>
        -userAggregate: User
        -activityAggregate: UserActivity
        -favoritesAggregate: UserFavorites
        +createUser(command: CreateUserCommand): Promise~User~
        +updateProfile(command: UpdateProfileCommand): Promise~void~
        +recordActivity(command: RecordActivityCommand): Promise~void~
    }
    
    class WorkoutContext {
        <<Bounded Context>>
        -workoutAggregate: Workout
        -templateAggregate: WorkoutTemplate
        +createWorkout(command: CreateWorkoutCommand): Promise~Workout~
        +executeWorkout(command: ExecuteWorkoutCommand): Promise~WorkoutSession~
        +shareWorkout(command: ShareWorkoutCommand): Promise~void~
    }
    
    class ProgressionContext {
        <<Bounded Context>>
        -progressionAggregate: ProgressionTracking
        -recordAggregate: PersonalRecord
        -goalAggregate: GoalTracking
        +recordPerformance(command: RecordPerformanceCommand): Promise~PersonalRecord~
        +setGoal(command: SetGoalCommand): Promise~Goal~
        +analyzeProgress(query: AnalyzeProgressQuery): Promise~ProgressInsights~
    }
    
    class AIRecommendationEngine {
        <<AI/ML Pattern>>
        -modelManager: MLModelManager
        -personalizationEngine: PersonalizationEngine
        -predictionService: PredictionService
        +recommend(userId: string, context: RecommendationContext): Promise~Recommendation[]~
        +personalize(userId: string, preferences: UserPreferences): Promise~PersonalizedContent~
        +predict(input: PredictionInput): Promise~PredictionResult~
    }
    
    %% ===== RELATIONSHIPS =====
    
    %% Presentation to Application
    APIGateway --> ApplicationFacade : routes requests
    APIGateway --> MiddlewareChain : applies middleware
    MiddlewareChain --> IMiddleware : executes chain
    
    %% Application Layer Relationships
    ApplicationFacade --> CommandBus : dispatches commands
    ApplicationFacade --> QueryBus : dispatches queries
    ApplicationFacade --> EventBus : publishes events
    
    %% CQRS Relationships
    CommandBus --> EventStore : persists events
    QueryBus --> ReadModelStore : queries projections
    EventBus --> SagaOrchestrator : triggers sagas
    EventBus --> ReadModelStore : updates projections
    
    %% Domain Relationships
    BoundedContext --> AggregateRoot : contains
    AggregateRoot --> DomainEvent : produces
    BoundedContext --> Port : defines
    Port --> Adapter : implemented by
    
    %% Infrastructure Relationships
    EventStore --> CacheManager : caches events
    ReadModelStore --> CacheManager : caches queries
    Adapter --> ServiceRegistry : registers services
    
    %% Cross-Cutting Relationships
    ApplicationFacade --> SecurityContext : enforces security
    CommandBus --> MetricsCollector : records metrics
    QueryBus --> MetricsCollector : records metrics
    Adapter --> CircuitBreaker : protects calls
    ServiceRegistry --> ConfigurationManager : gets config
    
    %% Context Relationships
    UserManagementContext --|> BoundedContext : extends
    WorkoutContext --|> BoundedContext : extends
    ProgressionContext --|> BoundedContext : extends
    
    %% Advanced Pattern Relationships
    SagaOrchestrator --> WorkflowEngine : orchestrates workflows
    PluginManager --> SecurityContext : validates permissions
    AIRecommendationEngine --> MetricsCollector : tracks performance
    